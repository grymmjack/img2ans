''
' QB64_GJ_LIB
' ENHANCED BOUNDING BOX OBJECT IMPLEMENTATION
'
' Complete implementation following the state machine diagram.
' Provides full selection, movement, resizing, and zoom functionality.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Creates an enhanced bounding box with full state machine support
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box to initialize
' @param LONG canvas_image destination image handle
' @param INTEGER x initial x position
' @param INTEGER y initial y position  
' @param INTEGER w initial width
' @param INTEGER h initial height
'
SUB ENHANCED_BBOX_create(ebb AS __ENHANCED_BOUNDING_BOX, canvas_image&, x%, y%, w%, h%)
    ' Initialize with defaults
    ebb = ENHANCED_BBOX_INIT
    
    ' Set specific values
    ebb.pos.x = x%
    ebb.pos.y = y%
    ebb.w = w%
    ebb.h = h%
    ebb.canvas = canvas_image&
    ebb.canvas_w = _WIDTH(canvas_image&)
    ebb.canvas_h = _HEIGHT(canvas_image&)
    
    ' Create clean canvas backup
    CALL ENHANCED_BBOX_update_canvas(ebb)
    
    ' Set initial state
    DIM init_result AS INTEGER
    init_result = ENHANCED_BBOX_set_state(ebb, ESTATE_DESELECTED)
    
    ' Render initial state
    CALL ENHANCED_BBOX_render(ebb)
END SUB


''
' Updates the canvas backup for the enhanced bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_update_canvas(ebb AS __ENHANCED_BOUNDING_BOX)
    DIM AS LONG old_dest
    old_dest = _DEST
    
    ' Free previous clean canvas if it exists
    IF ebb.clean_canvas < -1 THEN _FREEIMAGE ebb.clean_canvas
    
    ' Create new clean canvas backup
    ebb.clean_canvas = _NEWIMAGE(ebb.canvas_w, ebb.canvas_h, 32)
    _DEST ebb.clean_canvas
    CLS
    _PUTIMAGE (0, 0), ebb.canvas, ebb.clean_canvas
    
    _DEST old_dest
    ebb.status.ready = TRUE
END SUB


''
' Sets the state of the enhanced bounding box with proper validation
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param STRING new_state$ state to transition to
' @return INTEGER TRUE if transition successful, FALSE otherwise
'
FUNCTION ENHANCED_BBOX_set_state%(ebb AS __ENHANCED_BOUNDING_BOX, new_state$)
    IF ENHANCED_BBOX_can_transition(ebb, new_state$) THEN
        ' Clear all state flags
        ebb.status.deselected = FALSE
        ebb.status.over = FALSE
        ebb.status.selected = FALSE
        ebb.status.zooming = FALSE
        ebb.status.resizing = FALSE
        ebb.status.moving = FALSE
        
        ' Set new state
        SELECT CASE new_state$
            CASE ESTATE_DESELECTED
                ebb.status.deselected = TRUE
            CASE ESTATE_OVER
                ebb.status.over = TRUE
            CASE ESTATE_SELECTED
                ebb.status.selected = TRUE
            CASE ESTATE_ZOOMING
                ebb.status.zooming = TRUE
            CASE ESTATE_RESIZING
                ebb.status.resizing = TRUE
            CASE ESTATE_MOVING
                ebb.status.moving = TRUE
        END SELECT
        
        ebb.current_state = new_state$
        ENHANCED_BBOX_set_state% = TRUE
    ELSE
        ENHANCED_BBOX_set_state% = FALSE
    END IF
END FUNCTION


''
' Checks if state transition is valid per the state machine diagram
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param STRING new_state$ target state
' @return INTEGER TRUE if transition is valid
'
FUNCTION ENHANCED_BBOX_can_transition%(ebb AS __ENHANCED_BOUNDING_BOX, new_state$)
    SELECT CASE ebb.current_state
        CASE ESTATE_DESELECTED
            ' From DESELECTED: can go to OVER or SELECTED (via Left Click)
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_OVER) OR (new_state$ = ESTATE_SELECTED)
            
        CASE ESTATE_OVER
            ' From OVER: can go to DESELECTED, SELECTED, or ZOOMING
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_DESELECTED) OR _
                                          (new_state$ = ESTATE_SELECTED) OR _
                                          (new_state$ = ESTATE_ZOOMING)
            
        CASE ESTATE_SELECTED
            ' From SELECTED: can go to DESELECTED, RESIZING, or MOVING
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_DESELECTED) OR _
                                          (new_state$ = ESTATE_RESIZING) OR _
                                          (new_state$ = ESTATE_MOVING)
            
        CASE ESTATE_ZOOMING
            ' From ZOOMING: can go back to DESELECTED or OVER
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_DESELECTED) OR _
                                          (new_state$ = ESTATE_OVER)
            
        CASE ESTATE_RESIZING
            ' From RESIZING: can go back to SELECTED
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_SELECTED)
            
        CASE ESTATE_MOVING
            ' From MOVING: can go back to SELECTED
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_SELECTED)
            
        CASE ELSE
            ' Invalid current state, allow transition to DESELECTED to recover
            ENHANCED_BBOX_can_transition% = (new_state$ = ESTATE_DESELECTED)
    END SELECT
END FUNCTION


''
' Renders the enhanced bounding box based on current state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_render(ebb AS __ENHANCED_BOUNDING_BOX)
    IF NOT ebb.status.ready OR NOT ebb.status.visible THEN EXIT SUB
    
    DIM AS LONG old_dest
    DIM style AS __STYLE
    
    old_dest = _DEST
    _DEST ebb.canvas
    
    ' Restore clean background first
    _PUTIMAGE (0, 0), ebb.clean_canvas, ebb.canvas
    
    ' Get style for current state
    SELECT CASE ebb.current_state
        CASE ESTATE_DESELECTED
            style = ebb.styles.deselected
        CASE ESTATE_OVER
            style = ebb.styles.over
        CASE ESTATE_SELECTED
            style = ebb.styles.selected
        CASE ESTATE_ZOOMING
            style = ebb.styles.zooming
        CASE ESTATE_RESIZING
            style = ebb.styles.resizing
        CASE ESTATE_MOVING
            style = ebb.styles.moving
    END SELECT
    
    ' Draw the bounding box
    CALL ENHANCED_BBOX_draw_border(ebb, style)
    
    ' Draw resize handles if selected
    IF ebb.current_state = ESTATE_SELECTED OR ebb.current_state = ESTATE_RESIZING THEN
        CALL ENHANCED_BBOX_draw_resize_handles(ebb, style)
    END IF
    
    _DEST old_dest
END SUB


''
' Draws the border of the bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __STYLE style style to use for drawing
'
SUB ENHANCED_BBOX_draw_border(ebb AS __ENHANCED_BOUNDING_BOX, style AS __STYLE)
    DIM AS INTEGER i, x1, y1, x2, y2
    
    x1 = ebb.pos.x
    y1 = ebb.pos.y
    x2 = ebb.pos.x + ebb.w
    y2 = ebb.pos.y + ebb.h
    
    ' Draw border with specified width and pattern
    FOR i = 0 TO style.border.w - 1
        LINE (x1 + i, y1 + i)-(x2 - i - 1, y2 - i - 1), style.border.fg, B, style.border.pattern
    NEXT i
END SUB


''
' Draws resize handles around the selected bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box  
' @param __STYLE style style to use for handles
'
SUB ENHANCED_BBOX_draw_resize_handles(ebb AS __ENHANCED_BOUNDING_BOX, style AS __STYLE)
    DIM AS INTEGER handle_size, x1, y1, x2, y2, mx, my
    DIM AS _UNSIGNED LONG handle_color
    
    handle_size = 6
    handle_color = _RGB32(255, 255, 255)
    
    x1 = ebb.pos.x
    y1 = ebb.pos.y
    x2 = ebb.pos.x + ebb.w
    y2 = ebb.pos.y + ebb.h
    mx = x1 + ebb.w \ 2
    my = y1 + ebb.h \ 2
    
    ' Draw corner handles
    CALL ENHANCED_BBOX_draw_handle(x1, y1, handle_size, handle_color)         ' Top-left
    CALL ENHANCED_BBOX_draw_handle(x2, y1, handle_size, handle_color)         ' Top-right
    CALL ENHANCED_BBOX_draw_handle(x1, y2, handle_size, handle_color)         ' Bottom-left
    CALL ENHANCED_BBOX_draw_handle(x2, y2, handle_size, handle_color)         ' Bottom-right
    
    ' Draw edge handles
    CALL ENHANCED_BBOX_draw_handle(mx, y1, handle_size, handle_color)         ' Top
    CALL ENHANCED_BBOX_draw_handle(mx, y2, handle_size, handle_color)         ' Bottom
    CALL ENHANCED_BBOX_draw_handle(x1, my, handle_size, handle_color)         ' Left
    CALL ENHANCED_BBOX_draw_handle(x2, my, handle_size, handle_color)         ' Right
END SUB


''
' Draws a single resize handle
' @param INTEGER x center x position
' @param INTEGER y center y position  
' @param INTEGER size handle size
' @param _UNSIGNED LONG handle_color handle color
'
SUB ENHANCED_BBOX_draw_handle(x%, y%, size%, handle_color~&)
    DIM AS INTEGER half_size
    half_size = size% \ 2
    
    ' Draw filled rectangle handle
    LINE (x% - half_size, y% - half_size)-(x% + half_size, y% + half_size), handle_color~&, BF
    
    ' Draw black border around handle
    LINE (x% - half_size, y% - half_size)-(x% + half_size, y% + half_size), _RGB32(0, 0, 0), B
END SUB


''
' Processes mouse events for the enhanced bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse state object
' @return INTEGER TRUE if box state changed
'
FUNCTION ENHANCED_BBOX_process_mouse%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE)
    DIM AS INTEGER point_over, state_changed, on_edge
    DIM AS STRING edge_type, cursor_type
    
    state_changed = FALSE
    point_over = ENHANCED_BBOX_point_inside(ebb, mouse.new_state.pos.x, mouse.new_state.pos.y)
    
    ' Update cursor based on current position
    CALL ENHANCED_BBOX_update_cursor(ebb, mouse.new_state.pos.x, mouse.new_state.pos.y)
    
    ' State machine processing
    SELECT CASE ebb.current_state
        CASE ESTATE_DESELECTED
            state_changed = ENHANCED_BBOX_process_deselected(ebb, mouse, point_over)
            
        CASE ESTATE_OVER
            state_changed = ENHANCED_BBOX_process_over(ebb, mouse, point_over)
            
        CASE ESTATE_SELECTED
            state_changed = ENHANCED_BBOX_process_selected(ebb, mouse, point_over)
            
        CASE ESTATE_ZOOMING
            state_changed = ENHANCED_BBOX_process_zooming(ebb, mouse)
            
        CASE ESTATE_RESIZING
            state_changed = ENHANCED_BBOX_process_resizing(ebb, mouse)
            
        CASE ESTATE_MOVING
            state_changed = ENHANCED_BBOX_process_moving(ebb, mouse)
    END SELECT
    
    ' Re-render if state changed
    IF state_changed THEN CALL ENHANCED_BBOX_render(ebb)
    
    ENHANCED_BBOX_process_mouse% = state_changed
END FUNCTION


''
' Process mouse events when in DESELECTED state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse object
' @param INTEGER point_over whether mouse is over the box
' @return INTEGER TRUE if state changed
'
FUNCTION ENHANCED_BBOX_process_deselected%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE, point_over%)
    IF point_over% THEN
        ' Mouse over box -> transition to OVER state
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_OVER) THEN
            ENHANCED_BBOX_process_deselected% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    
    ' Check for left click on box -> transition to SELECTED
    IF mouse.status.b1_clicked AND point_over% THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_SELECTED) THEN
            ENHANCED_BBOX_process_deselected% = TRUE
        END IF
    END IF
    
    ENHANCED_BBOX_process_deselected% = FALSE
END FUNCTION


''
' Process mouse events when in OVER state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse object  
' @param INTEGER point_over whether mouse is over the box
' @return INTEGER TRUE if state changed
'
FUNCTION ENHANCED_BBOX_process_over%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE, point_over%)
    ' Mouse moved away -> back to DESELECTED
    IF NOT point_over% THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_DESELECTED) THEN
            ENHANCED_BBOX_process_over% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    
    ' Left click -> SELECT
    IF mouse.status.b1_clicked AND point_over% THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_SELECTED) THEN
            ENHANCED_BBOX_process_over% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    
    ' Wheel events -> ZOOMING
    IF (mouse.status.wheeling_up OR mouse.status.wheeling_down) AND point_over% THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_ZOOMING) THEN
            ENHANCED_BBOX_process_over% = TRUE
        END IF
    END IF
    
    ENHANCED_BBOX_process_over% = FALSE
END FUNCTION


''
' Process mouse events when in SELECTED state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse object
' @param INTEGER point_over whether mouse is over the box  
' @return INTEGER TRUE if state changed
'
FUNCTION ENHANCED_BBOX_process_selected%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE, point_over%)
    DIM AS STRING edge_type
    
    ' Click outside box -> DESELECTED
    IF mouse.status.b1_clicked AND NOT point_over% THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_DESELECTED) THEN
            ENHANCED_BBOX_process_selected% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    
    ' Start dragging on edge -> RESIZING
    IF mouse.status.started_drag AND point_over% THEN
        edge_type$ = ENHANCED_BBOX_get_edge_type(ebb, mouse.new_state.pos.x, mouse.new_state.pos.y)
        IF edge_type$ <> "" THEN
            ' Store drag start info
            ebb.drag_start_pos.x = mouse.new_state.pos.x
            ebb.drag_start_pos.y = mouse.new_state.pos.y
            ebb.drag_start_size.x = ebb.w
            ebb.drag_start_size.y = ebb.h
            
            ' Set resize flags based on edge
            CALL ENHANCED_BBOX_set_resize_flags(ebb, edge_type$)
            
            IF ENHANCED_BBOX_set_state(ebb, ESTATE_RESIZING) THEN
                ENHANCED_BBOX_process_selected% = TRUE
                EXIT FUNCTION
            END IF
        ELSE
            ' Dragging inside box (not on edge) -> MOVING
            ebb.drag_offset.x = mouse.new_state.pos.x - ebb.pos.x
            ebb.drag_offset.y = mouse.new_state.pos.y - ebb.pos.y
            
            IF ENHANCED_BBOX_set_state(ebb, ESTATE_MOVING) THEN
                ENHANCED_BBOX_process_selected% = TRUE
            END IF
        END IF
    END IF
    
    ENHANCED_BBOX_process_selected% = FALSE
END FUNCTION


''
' Process mouse events when in ZOOMING state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse object
' @return INTEGER TRUE if state changed  
'
FUNCTION ENHANCED_BBOX_process_zooming%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE)
    DIM AS SINGLE zoom_factor
    DIM AS INTEGER new_w, new_h, center_x, center_y
    
    ' Process zoom
    IF mouse.status.wheeling_up THEN
        zoom_factor = 1.1
        ebb.status.zoom_level = ebb.status.zoom_level * zoom_factor
    ELSEIF mouse.status.wheeling_down THEN
        zoom_factor = 0.9
        ebb.status.zoom_level = ebb.status.zoom_level * zoom_factor
    ELSE
        ' No wheel movement -> back to OVER state
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_OVER) THEN
            ENHANCED_BBOX_process_zooming% = TRUE
        END IF
        EXIT FUNCTION
    END IF
    
    ' Calculate new size maintaining center point
    center_x = ebb.pos.x + ebb.w \ 2
    center_y = ebb.pos.y + ebb.h \ 2
    
    new_w = INT(ebb.w * zoom_factor)
    new_h = INT(ebb.h * zoom_factor)
    
    ' Apply size constraints
    IF new_w < ebb.min_w THEN new_w = ebb.min_w
    IF new_h < ebb.min_h THEN new_h = ebb.min_h
    IF new_w > ebb.max_w THEN new_w = ebb.max_w
    IF new_h > ebb.max_h THEN new_h = ebb.max_h
    
    ' Update position to keep center point
    ebb.pos.x = center_x - new_w \ 2
    ebb.pos.y = center_y - new_h \ 2
    ebb.w = new_w
    ebb.h = new_h
    
    ' Constrain to canvas bounds
    CALL ENHANCED_BBOX_constrain_to_canvas(ebb)
    
    ENHANCED_BBOX_process_zooming% = TRUE
END FUNCTION


''
' Process mouse events when in RESIZING state  
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param __MOUSE mouse mouse object
' @return INTEGER TRUE if state changed
'
FUNCTION ENHANCED_BBOX_process_resizing%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE)
    DIM AS INTEGER dx, dy, new_x, new_y, new_w, new_h
    
    ' Stop dragging -> back to SELECTED
    IF mouse.status.stopped_drag OR NOT mouse.status.is_dragging THEN
        CALL ENHANCED_BBOX_clear_resize_flags(ebb)
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_SELECTED) THEN
            ENHANCED_BBOX_process_resizing% = TRUE
        END IF
        EXIT FUNCTION
    END IF
    
    ' Calculate mouse movement delta
    dx = mouse.new_state.pos.x - ebb.drag_start_pos.x
    dy = mouse.new_state.pos.y - ebb.drag_start_pos.y
    
    ' Apply resize based on active edges
    new_x = ebb.pos.x
    new_y = ebb.pos.y  
    new_w = ebb.w
    new_h = ebb.h
    
    ' Handle resize operations
    IF ebb.status.resizing_left THEN
        new_x = ebb.pos.x + dx
        new_w = ebb.drag_start_size.x - dx
    END IF
    
    IF ebb.status.resizing_right THEN
        new_w = ebb.drag_start_size.x + dx
    END IF
    
    IF ebb.status.resizing_top THEN
        new_y = ebb.pos.y + dy
        new_h = ebb.drag_start_size.y - dy
    END IF
    
    IF ebb.status.resizing_bottom THEN
        new_h = ebb.drag_start_size.y + dy
    END IF
    
    ' Apply size constraints
    IF new_w < ebb.min_w THEN
        IF ebb.status.resizing_left THEN new_x = ebb.pos.x + ebb.w - ebb.min_w
        new_w = ebb.min_w
    END IF
    
    IF new_h < ebb.min_h THEN
        IF ebb.status.resizing_top THEN new_y = ebb.pos.y + ebb.h - ebb.min_h
        new_h = ebb.min_h
    END IF
    
    IF new_w > ebb.max_w THEN new_w = ebb.max_w
    IF new_h > ebb.max_h THEN new_h = ebb.max_h
    
    ' Update bounding box
    ebb.pos.x = new_x
    ebb.pos.y = new_y
    ebb.w = new_w
    ebb.h = new_h
    
    ' Constrain to canvas
    CALL ENHANCED_BBOX_constrain_to_canvas(ebb)
    
    ENHANCED_BBOX_process_resizing% = TRUE
END FUNCTION


''
' Process mouse events when in MOVING state
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box  
' @param __MOUSE mouse mouse object
' @return INTEGER TRUE if state changed
'
FUNCTION ENHANCED_BBOX_process_moving%(ebb AS __ENHANCED_BOUNDING_BOX, mouse AS __MOUSE)
    ' Stop dragging -> back to SELECTED
    IF mouse.status.stopped_drag OR NOT mouse.status.is_dragging THEN
        IF ENHANCED_BBOX_set_state(ebb, ESTATE_SELECTED) THEN
            ENHANCED_BBOX_process_moving% = TRUE
        END IF
        EXIT FUNCTION
    END IF
    
    ' Update position based on mouse position minus offset
    ebb.pos.x = mouse.new_state.pos.x - ebb.drag_offset.x
    ebb.pos.y = mouse.new_state.pos.y - ebb.drag_offset.y
    
    ' Constrain to canvas bounds
    CALL ENHANCED_BBOX_constrain_to_canvas(ebb)
    
    ENHANCED_BBOX_process_moving% = TRUE
END FUNCTION


''
' Updates the mouse cursor based on position relative to bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER mouse_x mouse x position
' @param INTEGER mouse_y mouse y position
'
SUB ENHANCED_BBOX_update_cursor(ebb AS __ENHANCED_BOUNDING_BOX, mouse_x%, mouse_y%)
    DIM AS STRING edge_type, cursor_name
    
    ' Only show special cursors when selected or resizing
    IF ebb.current_state = ESTATE_SELECTED OR ebb.current_state = ESTATE_RESIZING THEN
        edge_type$ = ENHANCED_BBOX_get_edge_type(ebb, mouse_x%, mouse_y%)
        
        SELECT CASE edge_type$
            CASE "top_left", "bottom_right"
                cursor_name$ = "SIZENWSE"
            CASE "top_right", "bottom_left"
                cursor_name$ = "SIZENESW"
            CASE "left", "right"
                cursor_name$ = "SIZEWE"
            CASE "top", "bottom"
                cursor_name$ = "SIZENS"
            CASE ELSE
                cursor_name$ = "DEFAULT"
        END SELECT
    ELSE
        cursor_name$ = "DEFAULT"
    END IF
    
    ' Set cursor (QB64PE may not support all cursor types, fallback to default)
    _MOUSESHOW cursor_name$
END SUB


''
' Determines which edge/corner the point is on
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER x point x coordinate  
' @param INTEGER y point y coordinate
' @return STRING edge type or empty string if not on edge
'
FUNCTION ENHANCED_BBOX_get_edge_type$(ebb AS __ENHANCED_BOUNDING_BOX, x%, y%)
    DIM AS INTEGER tolerance, x1, y1, x2, y2
    DIM AS INTEGER on_left, on_right, on_top, on_bottom
    
    tolerance = ebb.status.edge_tolerance
    x1 = ebb.pos.x
    y1 = ebb.pos.y
    x2 = ebb.pos.x + ebb.w
    y2 = ebb.pos.y + ebb.h
    
    ' Check if near edges
    on_left = (x% >= x1 - tolerance AND x% <= x1 + tolerance)
    on_right = (x% >= x2 - tolerance AND x% <= x2 + tolerance)
    on_top = (y% >= y1 - tolerance AND y% <= y1 + tolerance)
    on_bottom = (y% >= y2 - tolerance AND y% <= y2 + tolerance)
    
    ' Check corners first
    IF on_top AND on_left THEN
        ENHANCED_BBOX_get_edge_type$ = "top_left"
    ELSEIF on_top AND on_right THEN
        ENHANCED_BBOX_get_edge_type$ = "top_right"
    ELSEIF on_bottom AND on_left THEN
        ENHANCED_BBOX_get_edge_type$ = "bottom_left"
    ELSEIF on_bottom AND on_right THEN
        ENHANCED_BBOX_get_edge_type$ = "bottom_right"
    ' Check edges
    ELSEIF on_left AND (y% >= y1 AND y% <= y2) THEN
        ENHANCED_BBOX_get_edge_type$ = "left"
    ELSEIF on_right AND (y% >= y1 AND y% <= y2) THEN
        ENHANCED_BBOX_get_edge_type$ = "right"
    ELSEIF on_top AND (x% >= x1 AND x% <= x2) THEN
        ENHANCED_BBOX_get_edge_type$ = "top"
    ELSEIF on_bottom AND (x% >= x1 AND x% <= x2) THEN
        ENHANCED_BBOX_get_edge_type$ = "bottom"
    ELSE
        ENHANCED_BBOX_get_edge_type$ = ""
    END IF
END FUNCTION


''
' Sets resize flags based on edge type
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param STRING edge_type edge being resized
'
SUB ENHANCED_BBOX_set_resize_flags(ebb AS __ENHANCED_BOUNDING_BOX, edge_type$)
    CALL ENHANCED_BBOX_clear_resize_flags(ebb)
    
    SELECT CASE edge_type$
        CASE "top_left"
            ebb.status.resizing_top = TRUE
            ebb.status.resizing_left = TRUE
        CASE "top_right"
            ebb.status.resizing_top = TRUE
            ebb.status.resizing_right = TRUE
        CASE "bottom_left"
            ebb.status.resizing_bottom = TRUE
            ebb.status.resizing_left = TRUE
        CASE "bottom_right"
            ebb.status.resizing_bottom = TRUE
            ebb.status.resizing_right = TRUE
        CASE "left"
            ebb.status.resizing_left = TRUE
        CASE "right"
            ebb.status.resizing_right = TRUE
        CASE "top"
            ebb.status.resizing_top = TRUE
        CASE "bottom"
            ebb.status.resizing_bottom = TRUE
    END SELECT
END SUB


''
' Clears all resize flags
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_clear_resize_flags(ebb AS __ENHANCED_BOUNDING_BOX)
    ebb.status.resizing_left = FALSE
    ebb.status.resizing_right = FALSE
    ebb.status.resizing_top = FALSE
    ebb.status.resizing_bottom = FALSE
END SUB


''
' Checks if point is inside the bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER x point x coordinate
' @param INTEGER y point y coordinate  
' @return INTEGER TRUE if point is inside
'
FUNCTION ENHANCED_BBOX_point_inside%(ebb AS __ENHANCED_BOUNDING_BOX, x%, y%)
    ENHANCED_BBOX_point_inside% = (x% >= ebb.pos.x AND x% <= ebb.pos.x + ebb.w) AND _
                                 (y% >= ebb.pos.y AND y% <= ebb.pos.y + ebb.h)
END FUNCTION


''
' Constrains the bounding box to stay within canvas bounds
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_constrain_to_canvas(ebb AS __ENHANCED_BOUNDING_BOX)
    ' Constrain position
    IF ebb.pos.x < 0 THEN ebb.pos.x = 0
    IF ebb.pos.y < 0 THEN ebb.pos.y = 0
    IF ebb.pos.x + ebb.w > ebb.canvas_w THEN ebb.pos.x = ebb.canvas_w - ebb.w
    IF ebb.pos.y + ebb.h > ebb.canvas_h THEN ebb.pos.y = ebb.canvas_h - ebb.h
END SUB


''
' Shows the enhanced bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_show(ebb AS __ENHANCED_BOUNDING_BOX)
    ebb.status.visible = TRUE
    CALL ENHANCED_BBOX_render(ebb)
END SUB


''
' Hides the enhanced bounding box  
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_hide(ebb AS __ENHANCED_BOUNDING_BOX)
    ebb.status.visible = FALSE
    ' Restore clean canvas
    _PUTIMAGE (0, 0), ebb.clean_canvas, ebb.canvas
END SUB


''
' Gets the current selection rectangle coordinates
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER x1 output top-left x
' @param INTEGER y1 output top-left y
' @param INTEGER x2 output bottom-right x  
' @param INTEGER y2 output bottom-right y
'
SUB ENHANCED_BBOX_get_selection(ebb AS __ENHANCED_BOUNDING_BOX, x1%, y1%, x2%, y2%)
    x1% = ebb.pos.x
    y1% = ebb.pos.y
    x2% = ebb.pos.x + ebb.w
    y2% = ebb.pos.y + ebb.h
END SUB


''
' Sets the position of the enhanced bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER x new x position
' @param INTEGER y new y position
'
SUB ENHANCED_BBOX_set_position(ebb AS __ENHANCED_BOUNDING_BOX, x%, y%)
    ebb.pos.x = x%
    ebb.pos.y = y%
    CALL ENHANCED_BBOX_constrain_to_canvas(ebb)
    CALL ENHANCED_BBOX_render(ebb)
END SUB


''
' Sets the size of the enhanced bounding box
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
' @param INTEGER w new width
' @param INTEGER h new height
'
SUB ENHANCED_BBOX_set_size(ebb AS __ENHANCED_BOUNDING_BOX, w%, h%)
    ' Apply constraints
    IF w% < ebb.min_w THEN w% = ebb.min_w
    IF h% < ebb.min_h THEN h% = ebb.min_h
    IF w% > ebb.max_w THEN w% = ebb.max_w
    IF h% > ebb.max_h THEN h% = ebb.max_h
    
    ebb.w = w%
    ebb.h = h%
    CALL ENHANCED_BBOX_constrain_to_canvas(ebb)
    CALL ENHANCED_BBOX_render(ebb)
END SUB


''
' Cleanup function to free resources
' @param __ENHANCED_BOUNDING_BOX ebb enhanced bounding box
'
SUB ENHANCED_BBOX_cleanup(ebb AS __ENHANCED_BOUNDING_BOX)
    ' No clean canvas to free - just mark as not ready
    ebb.status.ready = FALSE
END SUB
